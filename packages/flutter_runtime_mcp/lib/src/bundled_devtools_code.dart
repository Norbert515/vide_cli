// GENERATED FILE - DO NOT EDIT
// Generated by: dart run tool/generate_bundled_devtools.dart
// Source: packages/runtime_ai_dev_tools/lib/

/// Bundled imports for the synthetic main file
const String bundledImports = '''
// === Bundled runtime_ai_dev_tools imports ===
import 'dart:convert';
import 'dart:developer' as developer;
import 'dart:io';
import 'dart:ui' as ui;
import 'package:flutter/gestures.dart';
import 'package:flutter/material.dart';
import 'package:flutter/rendering.dart';
import 'package:flutter/services.dart';
import 'package:flutter/widgets.dart';
''';

/// Bundled runtime_ai_dev_tools code for the synthetic main file
const String bundledCode = r'''
// === Bundled runtime_ai_dev_tools code ===

// ============================================================================
// tap_visualization.dart
// ============================================================================

/// Singleton service to manage tap visualization overlays
class _TapVisualizationService {
  static final _TapVisualizationService _instance =
      _TapVisualizationService._internal();

  factory _TapVisualizationService() => _instance;

  _TapVisualizationService._internal();

  OverlayEntry? _currentOverlay;
  OverlayEntry? _persistentCursorOverlay;
  OverlayEntry? _scrollPathOverlay;
  OverlayEntry? _scrollEndIndicatorOverlay;
  OverlayEntry? _inspectionPulseOverlay;
  GlobalKey<OverlayState>? _overlayKey;

  /// Current cursor position in logical pixels (null if no cursor set)
  Offset? _cursorPosition;

  /// Get the current cursor position
  Offset? get cursorPosition => _cursorPosition;

  /// Sets the cursor position and shows a persistent cursor overlay (if overlay key is registered)
  /// This is the preferred method for service extensions as it doesn't require a BuildContext
  void setCursorPosition(double x, double y) {
    // Clear any existing cursor overlay
    _persistentCursorOverlay?.remove();
    _persistentCursorOverlay = null;

    // Store the cursor position
    _cursorPosition = Offset(x, y);

    // Try to show the cursor overlay if we have a registered overlay key
    if (_overlayKey?.currentState != null) {
      _persistentCursorOverlay = OverlayEntry(
        builder: (context) => _PersistentCursor(x: x, y: y),
      );

      WidgetsBinding.instance.addPostFrameCallback((_) {
        try {
          if (_persistentCursorOverlay != null &&
              _overlayKey?.currentState != null) {
            _overlayKey!.currentState!.insert(_persistentCursorOverlay!);
                      }
        } catch (e) {
                  }
      });
    } else {
          }
  }

  /// Clears just the cursor position and overlay
  void clearCursorPosition() {
    _persistentCursorOverlay?.remove();
    _persistentCursorOverlay = null;
    _cursorPosition = null;
  }

  /// Register the overlay key from _DebugOverlayWrapper
  void setOverlayKey(GlobalKey<OverlayState> key) {
    _overlayKey = key;
      }

  /// Shows a tap visualization at the specified position
  void showTapAt(BuildContext context, double x, double y) {
    // Remove any existing overlay
    _currentOverlay?.remove();
    _currentOverlay = null;

    // Create new overlay entry
    _currentOverlay = OverlayEntry(
      builder: (context) => _TapVisualization(
        x: x,
        y: y,
        onComplete: () {
          _currentOverlay?.remove();
          _currentOverlay = null;
        },
      ),
    );

    // Insert overlay after current frame to avoid interfering with event dispatch
    WidgetsBinding.instance.addPostFrameCallback((_) {
      try {
        if (_currentOverlay != null) {
          // Use our custom overlay if available, otherwise fall back to context-based lookup
          final overlayState = _overlayKey?.currentState ?? Overlay.of(context);
          overlayState.insert(_currentOverlay!);
                  }
      } catch (e) {
              }
    });
  }

  /// Clears any active overlay
  void clear() {
    _currentOverlay?.remove();
    _currentOverlay = null;
  }

  /// Sets a persistent cursor at the specified position that stays visible until explicitly cleared
  /// This is useful for screenshots so the agent can see where the tap occurred
  void setPersistentCursor(BuildContext context, double x, double y) {
    // Remove any existing persistent cursor
    clearPersistentCursor();

    // Store the cursor position
    _cursorPosition = Offset(x, y);

    // Create new persistent cursor overlay
    _persistentCursorOverlay = OverlayEntry(
      builder: (context) => _PersistentCursor(x: x, y: y),
    );

    // Insert overlay after current frame
    WidgetsBinding.instance.addPostFrameCallback((_) {
      try {
        if (_persistentCursorOverlay != null) {
          final overlayState = _overlayKey?.currentState ?? Overlay.of(context);
          overlayState.insert(_persistentCursorOverlay!);
                  }
      } catch (e) {
              }
    });
  }

  /// Clears the persistent cursor overlay and position
  void clearPersistentCursor() {
    _persistentCursorOverlay?.remove();
    _persistentCursorOverlay = null;
    _cursorPosition = null;
  }

  /// Shows an animated scroll path from start to end
  void showScrollPath(
      BuildContext context, Offset start, Offset end, Duration duration) {
    // Remove any existing scroll path overlay
    _scrollPathOverlay?.remove();
    _scrollPathOverlay = null;

    // Create new overlay entry for scroll path animation
    _scrollPathOverlay = OverlayEntry(
      builder: (context) => _ScrollPathVisualization(
        start: start,
        end: end,
        duration: duration,
        onComplete: () {
          _scrollPathOverlay?.remove();
          _scrollPathOverlay = null;
        },
      ),
    );

    // Insert overlay after current frame
    WidgetsBinding.instance.addPostFrameCallback((_) {
      try {
        if (_scrollPathOverlay != null) {
          final overlayState = _overlayKey?.currentState ?? Overlay.of(context);
          overlayState.insert(_scrollPathOverlay!);
                  }
      } catch (e) {
              }
    });
  }

  /// Sets a persistent indicator showing scroll start and end positions
  void setScrollEndIndicator(BuildContext context, Offset start, Offset end) {
    // Remove any existing scroll end indicator
    clearScrollEndIndicator();

    _scrollEndIndicatorOverlay = OverlayEntry(
      builder: (context) => _ScrollEndIndicator(start: start, end: end),
    );

    // Insert overlay after current frame
    WidgetsBinding.instance.addPostFrameCallback((_) {
      try {
        if (_scrollEndIndicatorOverlay != null) {
          final overlayState = _overlayKey?.currentState ?? Overlay.of(context);
          overlayState.insert(_scrollEndIndicatorOverlay!);
                  }
      } catch (e) {
              }
    });
  }

  /// Clears the scroll end indicator overlay
  void clearScrollEndIndicator() {
    _scrollEndIndicatorOverlay?.remove();
    _scrollEndIndicatorOverlay = null;
  }

  /// Clears the scroll path overlay
  void clearScrollPath() {
    _scrollPathOverlay?.remove();
    _scrollPathOverlay = null;
  }

  /// Shows an inspection pulse animation at the specified position
  /// This indicates that widget info is being retrieved at that location
  void showInspectionPulse(double x, double y) {
    // Remove any existing inspection pulse
    _inspectionPulseOverlay?.remove();
    _inspectionPulseOverlay = null;

    // Try to show the inspection pulse if we have a registered overlay key
    if (_overlayKey?.currentState != null) {
      _inspectionPulseOverlay = OverlayEntry(
        builder: (context) => _InspectionPulse(
          x: x,
          y: y,
          onComplete: () {
            _inspectionPulseOverlay?.remove();
            _inspectionPulseOverlay = null;
          },
        ),
      );

      WidgetsBinding.instance.addPostFrameCallback((_) {
        try {
          if (_inspectionPulseOverlay != null &&
              _overlayKey?.currentState != null) {
            _overlayKey!.currentState!.insert(_inspectionPulseOverlay!);
                      }
        } catch (e) {
                  }
      });
    }
  }
}

/// Widget that displays the tap visualization animation
class _TapVisualization extends StatefulWidget {
  final double x;
  final double y;
  final VoidCallback onComplete;

  const _TapVisualization({
    required this.x,
    required this.y,
    required this.onComplete,
  });

  @override
  State<_TapVisualization> createState() => _TapVisualizationState();
}

class _TapVisualizationState extends State<_TapVisualization>
    with SingleTickerProviderStateMixin {
  late AnimationController _controller;
  late Animation<double> _scaleAnimation;
  late Animation<double> _opacityAnimation;

  @override
  void initState() {
    super.initState();

    _controller = AnimationController(
      duration: const Duration(milliseconds: 600),
      vsync: this,
    );

    _scaleAnimation = Tween<double>(
      begin: 0.0,
      end: 100.0,
    ).animate(CurvedAnimation(
      parent: _controller,
      curve: Curves.easeOut,
    ));

    _opacityAnimation = Tween<double>(
      begin: 0.6,
      end: 0.0,
    ).animate(CurvedAnimation(
      parent: _controller,
      curve: Curves.easeOut,
    ));

    _controller.forward().then((_) {
      widget.onComplete();
    });
  }

  @override
  void dispose() {
    _controller.dispose();
    super.dispose();
  }

  @override
  Widget build(BuildContext context) {
    return IgnorePointer(
      child: AnimatedBuilder(
        animation: _controller,
        builder: (context, child) {
          return Stack(
            children: [
              Positioned(
                left: widget.x - _scaleAnimation.value / 2,
                top: widget.y - _scaleAnimation.value / 2,
                child: Container(
                  width: _scaleAnimation.value,
                  height: _scaleAnimation.value,
                  decoration: BoxDecoration(
                    shape: BoxShape.circle,
                    border: Border.all(
                      color: Colors.blue
                          .withValues(alpha: _opacityAnimation.value),
                      width: 2,
                    ),
                    color: Colors.blue
                        .withValues(alpha: _opacityAnimation.value * 0.3),
                  ),
                ),
              ),
            ],
          );
        },
      ),
    );
  }
}

/// Widget that displays a persistent cursor indicator
/// This stays visible until explicitly cleared, useful for screenshots
class _PersistentCursor extends StatelessWidget {
  final double x;
  final double y;

  const _PersistentCursor({
    required this.x,
    required this.y,
  });

  static const double _innerDotSize = 8.0;
  static const double _crosshairLength = 20.0;
  static const double _crosshairThickness = 2.0;

  @override
  Widget build(BuildContext context) {
    return IgnorePointer(
      child: Stack(
        children: [
          // Crosshair horizontal line
          Positioned(
            left: x - _crosshairLength / 2,
            top: y - _crosshairThickness / 2,
            child: Container(
              width: _crosshairLength,
              height: _crosshairThickness,
              color: Colors.deepOrange,
            ),
          ),
          // Crosshair vertical line
          Positioned(
            left: x - _crosshairThickness / 2,
            top: y - _crosshairLength / 2,
            child: Container(
              width: _crosshairThickness,
              height: _crosshairLength,
              color: Colors.deepOrange,
            ),
          ),
          // Center dot with border
          Positioned(
            left: x - _innerDotSize / 2,
            top: y - _innerDotSize / 2,
            child: Container(
              width: _innerDotSize,
              height: _innerDotSize,
              decoration: BoxDecoration(
                shape: BoxShape.circle,
                color: Colors.deepOrange,
                border: Border.all(
                  color: Colors.white,
                  width: 1.5,
                ),
                boxShadow: [
                  BoxShadow(
                    color: Colors.black.withValues(alpha: 0.3),
                    blurRadius: 2,
                    offset: const Offset(1, 1),
                  ),
                ],
              ),
            ),
          ),
        ],
      ),
    );
  }
}

/// Widget that displays an animated scroll path being drawn
class _ScrollPathVisualization extends StatefulWidget {
  final Offset start;
  final Offset end;
  final Duration duration;
  final VoidCallback onComplete;

  const _ScrollPathVisualization({
    required this.start,
    required this.end,
    required this.duration,
    required this.onComplete,
  });

  @override
  State<_ScrollPathVisualization> createState() =>
      _ScrollPathVisualizationState();
}

class _ScrollPathVisualizationState extends State<_ScrollPathVisualization>
    with SingleTickerProviderStateMixin {
  late AnimationController _controller;
  late Animation<double> _progressAnimation;
  late Animation<double> _fadeAnimation;

  @override
  void initState() {
    super.initState();

    // Total animation: draw the line, then hold briefly, then fade
    final totalDuration = widget.duration + const Duration(milliseconds: 500);

    _controller = AnimationController(
      duration: totalDuration,
      vsync: this,
    );

    // Line drawing happens during the scroll duration
    final drawEndTime =
        widget.duration.inMilliseconds / totalDuration.inMilliseconds;
    _progressAnimation = Tween<double>(
      begin: 0.0,
      end: 1.0,
    ).animate(CurvedAnimation(
      parent: _controller,
      curve: Interval(0.0, drawEndTime, curve: Curves.linear),
    ));

    // Fade out happens after the line is drawn
    _fadeAnimation = Tween<double>(
      begin: 1.0,
      end: 0.0,
    ).animate(CurvedAnimation(
      parent: _controller,
      curve: Interval(drawEndTime, 1.0, curve: Curves.easeOut),
    ));

    _controller.forward().then((_) {
      widget.onComplete();
    });
  }

  @override
  void dispose() {
    _controller.dispose();
    super.dispose();
  }

  @override
  Widget build(BuildContext context) {
    return IgnorePointer(
      child: AnimatedBuilder(
        animation: _controller,
        builder: (context, child) {
          return CustomPaint(
            size: Size.infinite,
            painter: _ScrollPathPainter(
              start: widget.start,
              end: widget.end,
              progress: _progressAnimation.value,
              opacity: _fadeAnimation.value,
            ),
          );
        },
      ),
    );
  }
}

/// Custom painter that draws an animated scroll path with arrow
class _ScrollPathPainter extends CustomPainter {
  final Offset start;
  final Offset end;
  final double progress;
  final double opacity;

  _ScrollPathPainter({
    required this.start,
    required this.end,
    required this.progress,
    required this.opacity,
  });

  @override
  void paint(Canvas canvas, Size size) {
    if (opacity <= 0) return;

    final paint = Paint()
      ..color = Colors.green.withValues(alpha: opacity * 0.8)
      ..strokeWidth = 4.0
      ..strokeCap = StrokeCap.round
      ..style = PaintingStyle.stroke;

    // Calculate current end position based on progress
    final currentEnd = Offset(
      start.dx + (end.dx - start.dx) * progress,
      start.dy + (end.dy - start.dy) * progress,
    );

    // Draw the line
    canvas.drawLine(start, currentEnd, paint);

    // Draw start circle
    final circlePaint = Paint()
      ..color = Colors.green.withValues(alpha: opacity)
      ..style = PaintingStyle.fill;
    canvas.drawCircle(start, 6, circlePaint);

    // Draw arrowhead at current position if we have progress
    if (progress > 0.1) {
      _drawArrowhead(canvas, currentEnd, paint);
    }
  }

  void _drawArrowhead(Canvas canvas, Offset tip, Paint paint) {
    final direction = (end - start).direction;
    const arrowSize = 12.0;
    const arrowAngle = 0.5; // radians

    final point1 = Offset(
      tip.dx - arrowSize * _bundledCos(direction - arrowAngle),
      tip.dy - arrowSize * _bundledSin(direction - arrowAngle),
    );
    final point2 = Offset(
      tip.dx - arrowSize * _bundledCos(direction + arrowAngle),
      tip.dy - arrowSize * _bundledSin(direction + arrowAngle),
    );

    final arrowPath = Path()
      ..moveTo(tip.dx, tip.dy)
      ..lineTo(point1.dx, point1.dy)
      ..moveTo(tip.dx, tip.dy)
      ..lineTo(point2.dx, point2.dy);

    canvas.drawPath(arrowPath, paint);
  }

  @override
  bool shouldRepaint(_ScrollPathPainter oldDelegate) {
    return oldDelegate.progress != progress || oldDelegate.opacity != opacity;
  }
}

/// Widget that displays a persistent scroll end indicator
class _ScrollEndIndicator extends StatelessWidget {
  final Offset start;
  final Offset end;

  const _ScrollEndIndicator({
    required this.start,
    required this.end,
  });

  @override
  Widget build(BuildContext context) {
    return IgnorePointer(
      child: CustomPaint(
        size: Size.infinite,
        painter: _ScrollEndPainter(start: start, end: end),
      ),
    );
  }
}

/// Custom painter for the persistent scroll indicator
class _ScrollEndPainter extends CustomPainter {
  final Offset start;
  final Offset end;

  _ScrollEndPainter({required this.start, required this.end});

  @override
  void paint(Canvas canvas, Size size) {
    // Draw line
    final linePaint = Paint()
      ..color = Colors.green.withValues(alpha: 0.6)
      ..strokeWidth = 3.0
      ..strokeCap = StrokeCap.round
      ..style = PaintingStyle.stroke;

    canvas.drawLine(start, end, linePaint);

    // Draw start circle (hollow)
    final startPaint = Paint()
      ..color = Colors.green
      ..strokeWidth = 2.0
      ..style = PaintingStyle.stroke;
    canvas.drawCircle(start, 8, startPaint);

    // Draw end circle (filled)
    final endPaint = Paint()
      ..color = Colors.green
      ..style = PaintingStyle.fill;
    canvas.drawCircle(end, 6, endPaint);

    // Draw arrow on line
    _drawArrowhead(canvas, end, linePaint);
  }

  void _drawArrowhead(Canvas canvas, Offset tip, Paint paint) {
    final direction = (end - start).direction;
    const arrowSize = 14.0;
    const arrowAngle = 0.5;

    final point1 = Offset(
      tip.dx - arrowSize * _bundledCos(direction - arrowAngle),
      tip.dy - arrowSize * _bundledSin(direction - arrowAngle),
    );
    final point2 = Offset(
      tip.dx - arrowSize * _bundledCos(direction + arrowAngle),
      tip.dy - arrowSize * _bundledSin(direction + arrowAngle),
    );

    final arrowPath = Path()
      ..moveTo(tip.dx, tip.dy)
      ..lineTo(point1.dx, point1.dy)
      ..moveTo(tip.dx, tip.dy)
      ..lineTo(point2.dx, point2.dy);

    final arrowPaint = Paint()
      ..color = Colors.green
      ..strokeWidth = 3.0
      ..strokeCap = StrokeCap.round
      ..style = PaintingStyle.stroke;

    canvas.drawPath(arrowPath, arrowPaint);
  }

  @override
  bool shouldRepaint(_ScrollEndPainter oldDelegate) {
    return oldDelegate.start != start || oldDelegate.end != end;
  }
}

/// Widget that displays an inspection pulse animation
/// Shows a purple pulsing effect to indicate widget inspection
class _InspectionPulse extends StatefulWidget {
  final double x;
  final double y;
  final VoidCallback onComplete;

  const _InspectionPulse({
    required this.x,
    required this.y,
    required this.onComplete,
  });

  @override
  State<_InspectionPulse> createState() => _InspectionPulseState();
}

class _InspectionPulseState extends State<_InspectionPulse>
    with SingleTickerProviderStateMixin {
  late AnimationController _controller;
  late Animation<double> _scaleAnimation;
  late Animation<double> _opacityAnimation;

  @override
  void initState() {
    super.initState();

    _controller = AnimationController(
      duration: const Duration(milliseconds: 800),
      vsync: this,
    );

    // Pulsing scale animation
    _scaleAnimation = Tween<double>(
      begin: 20.0,
      end: 80.0,
    ).animate(CurvedAnimation(
      parent: _controller,
      curve: Curves.easeOut,
    ));

    // Fade out animation
    _opacityAnimation = Tween<double>(
      begin: 0.7,
      end: 0.0,
    ).animate(CurvedAnimation(
      parent: _controller,
      curve: Curves.easeOut,
    ));

    _controller.forward().then((_) {
      widget.onComplete();
    });
  }

  @override
  void dispose() {
    _controller.dispose();
    super.dispose();
  }

  @override
  Widget build(BuildContext context) {
    return IgnorePointer(
      child: AnimatedBuilder(
        animation: _controller,
        builder: (context, child) {
          return Stack(
            children: [
              // Outer pulsing ring
              Positioned(
                left: widget.x - _scaleAnimation.value / 2,
                top: widget.y - _scaleAnimation.value / 2,
                child: Container(
                  width: _scaleAnimation.value,
                  height: _scaleAnimation.value,
                  decoration: BoxDecoration(
                    shape: BoxShape.circle,
                    border: Border.all(
                      color: Colors.purple
                          .withValues(alpha: _opacityAnimation.value),
                      width: 3,
                    ),
                  ),
                ),
              ),
              // Inner static ring (inspection indicator)
              Positioned(
                left: widget.x - 15,
                top: widget.y - 15,
                child: Container(
                  width: 30,
                  height: 30,
                  decoration: BoxDecoration(
                    shape: BoxShape.circle,
                    border: Border.all(
                      color: Colors.purple
                          .withValues(alpha: _opacityAnimation.value * 1.2),
                      width: 2,
                    ),
                    color: Colors.purple
                        .withValues(alpha: _opacityAnimation.value * 0.2),
                  ),
                  child: Icon(
                    Icons.search,
                    size: 16,
                    color: Colors.purple
                        .withValues(alpha: _opacityAnimation.value * 1.5),
                  ),
                ),
              ),
            ],
          );
        },
      ),
    );
  }
}

// Math functions for arrow drawing
double _bundledCos(double radians) => _cos(radians);
double _bundledSin(double radians) => _sin(radians);

double _cos(double x) {
  // Simple cosine using Taylor series approximation
  x = x % (2 * 3.14159265359);
  double result = 1.0;
  double term = 1.0;
  for (int i = 1; i <= 10; i++) {
    term *= -x * x / ((2 * i - 1) * (2 * i));
    result += term;
  }
  return result;
}

double _sin(double x) {
  // Simple sine using Taylor series approximation
  x = x % (2 * 3.14159265359);
  double result = x;
  double term = x;
  for (int i = 1; i <= 10; i++) {
    term *= -x * x / ((2 * i) * (2 * i + 1));
    result += term;
  }
  return result;
}

// ============================================================================
// screenshot_extension.dart
// ============================================================================

/// Registers the screenshot service extension
void _registerScreenshotExtension() {
  
  developer.registerExtension(
    'ext.runtime_ai_dev_tools.screenshot',
    (String method, Map<String, String> parameters) async {
                        try {
        final image = await _captureScreenshot();
        final base64Image = await _imageToBase64(image);

        // Get the device pixel ratio from the Flutter window
        final devicePixelRatio = WidgetsBinding
            .instance.platformDispatcher.views.first.devicePixelRatio;

        return developer.ServiceExtensionResponse.result(
          json.encode({
            'status': 'success',
            'image': base64Image,
            'devicePixelRatio': devicePixelRatio,
          }),
        );
      } catch (e, stackTrace) {
        return developer.ServiceExtensionResponse.error(
          developer.ServiceExtensionResponse.extensionError,
          'Failed to capture screenshot: $e\n$stackTrace',
        );
      }
    },
  );
}

/// Captures a screenshot of the root widget tree
Future<ui.Image> _captureScreenshot() async {
  final renderObject = WidgetsBinding.instance.rootElement?.findRenderObject();

  if (renderObject == null) {
    throw Exception('Root render object not found');
  }

  // Traverse up the tree to find a RenderRepaintBoundary
  RenderObject? current = renderObject;
  while (current != null && current is! RenderRepaintBoundary) {
    current = current.parent;
  }

  // If we found a RenderRepaintBoundary, use it
  if (current is RenderRepaintBoundary) {
    return await current.toImage(pixelRatio: 2.0);
  }

  // If no RenderRepaintBoundary found, use the layer approach
  // Get the layer from the render object and convert it to an image
  final layer = renderObject.debugLayer;
  if (layer == null) {
    throw Exception('No layer found on render object');
  }

  // Use the layer's buildScene to create an image
  final scene = layer.buildScene(ui.SceneBuilder());
  final image = await scene.toImage(
    renderObject.paintBounds.width.ceil(),
    renderObject.paintBounds.height.ceil(),
  );
  scene.dispose();

  return image;
}

/// Converts a UI image to base64-encoded PNG string
Future<String> _imageToBase64(ui.Image image) async {
  final byteData = await image.toByteData(format: ui.ImageByteFormat.png);
  image.dispose();

  if (byteData == null) {
    throw Exception('Failed to convert image to byte data');
  }

  final buffer = byteData.buffer.asUint8List();
  return base64Encode(buffer);
}

// ============================================================================
// tap_extension.dart
// ============================================================================

/// Counter for unique pointer IDs in tap gestures.
/// Each tap needs a unique pointer ID for Flutter's gesture system.
int _nextTapPointer = 1;

int _getNextTapPointer() {
  final result = _nextTapPointer;
  _nextTapPointer += 1;
  return result;
}

/// Registers the tap service extension
void _registerTapExtension() {
  
  developer.registerExtension(
    'ext.runtime_ai_dev_tools.tap',
    (String method, Map<String, String> parameters) async {
                  
      try {
        final xStr = parameters['x'];
        final yStr = parameters['y'];

        if (xStr == null || yStr == null) {
          return developer.ServiceExtensionResponse.error(
            developer.ServiceExtensionResponse.invalidParams,
            'Missing required parameters: x and y',
          );
        }

        final x = double.tryParse(xStr);
        final y = double.tryParse(yStr);

        if (x == null || y == null) {
          return developer.ServiceExtensionResponse.error(
            developer.ServiceExtensionResponse.invalidParams,
            'Invalid x or y coordinate',
          );
        }

        await _simulateTap(x, y);

        return developer.ServiceExtensionResponse.result(
          json.encode({
            'status': 'success',
            'x': xStr,
            'y': yStr,
          }),
        );
      } catch (e, stackTrace) {
        return developer.ServiceExtensionResponse.error(
          developer.ServiceExtensionResponse.extensionError,
          'Failed to simulate tap: $e\n$stackTrace',
        );
      }
    },
  );
}

/// Simulates a tap at the specified coordinates
Future<void> _simulateTap(double x, double y) async {
  
  // Clear any existing scroll end indicator from previous gestures
  _TapVisualizationService().clearScrollEndIndicator();

  try {
    final binding = WidgetsBinding.instance;
    final offset = Offset(x, y);
    final pointer = _getNextTapPointer();
    
    // Show tap visualization first
    final rootContext = binding.rootElement;
    if (rootContext != null) {
            try {
        _TapVisualizationService().showTapAt(rootContext, x, y);
              } catch (e) {
                // Continue even if visualization fails
      }
    } else {
          }

    // Register the pointer device first
        final addEvent = PointerAddedEvent(position: offset, pointer: pointer);
    binding.handlePointerEvent(addEvent);
    
    // Send pointer down event with unique pointer ID
        final downEvent = PointerDownEvent(position: offset, pointer: pointer);
    binding.handlePointerEvent(downEvent);
    
    // Wait 100ms for realistic tap duration
        await Future.delayed(const Duration(milliseconds: 100));

    // Send pointer up event with same pointer ID
        final upEvent = PointerUpEvent(position: offset, pointer: pointer);
    binding.handlePointerEvent(upEvent);
    
    // Unregister the pointer device
        final removeEvent = PointerRemovedEvent(position: offset, pointer: pointer);
    binding.handlePointerEvent(removeEvent);
    
    // Set persistent cursor so screenshots show where the tap occurred
    if (rootContext != null) {
      try {
        _TapVisualizationService().setPersistentCursor(rootContext, x, y);
              } catch (e) {
                // Continue even if persistent cursor fails
      }
    }

      } catch (e, stackTrace) {
            rethrow;
  }
}

// ============================================================================
// type_extension.dart
// ============================================================================

/// Pattern to match special key sequences like {enter}, {ctrl+c}, {alt+shift+tab}
final _specialKeyPattern = RegExp(r'\{([^}]+)\}');

/// Global text input state tracker
_TextInputTracker? _textInputTracker;

/// Registers the type service extension
void _registerTypeExtension() {
  
  // Install the text input tracker to monitor IME state
  _textInputTracker = _TextInputTracker.install();

  developer.registerExtension(
    'ext.runtime_ai_dev_tools.type',
    (String method, Map<String, String> parameters) async {
            
      try {
        final text = parameters['text'];

        if (text == null) {
          return developer.ServiceExtensionResponse.error(
            developer.ServiceExtensionResponse.invalidParams,
            'Missing required parameter: text',
          );
        }

        final result = await _simulateTyping(text);

        return developer.ServiceExtensionResponse.result(
          json.encode({
            'status': 'success',
            'text': text,
            'method': result.name,
          }),
        );
      } catch (e, stackTrace) {
                        return developer.ServiceExtensionResponse.error(
          developer.ServiceExtensionResponse.extensionError,
          'Failed to simulate typing: $e\n$stackTrace',
        );
      }
    },
  );

  // Register status extension
  developer.registerExtension(
    'ext.runtime_ai_dev_tools.type_status',
    (String method, Map<String, String> parameters) async {
      final tracker = _textInputTracker;
      return developer.ServiceExtensionResponse.result(
        json.encode({
          'hasActiveClient': tracker?.hasActiveClient ?? false,
          'clientId': tracker?.currentClientId,
          'currentText': tracker?.currentValue?.text,
          'cursorPosition': tracker?.currentValue?.selection.baseOffset,
        }),
      );
    },
  );
}

/// Injection method used
enum _InjectionMethod {
  imeChannel, // Low-level IME channel (most reliable for TextFields)
  textInputClient, // Direct TextInputClient.updateEditingValue
  rawKeyEvent, // Raw keyboard events (for terminals, games)
}

/// Simulates typing the given text with special key support.
///
/// Strategy (in order of preference):
/// 1. IME Channel: If there's an active TextInput client, inject via channel
/// 2. TextInputClient: Direct widget API if found in tree
/// 3. Raw Key Events: For terminals, games, and Focus-based widgets
Future<_InjectionMethod> _simulateTyping(String text) async {
  final tokens = _parseText(text);
  final tracker = _textInputTracker;
  final hasImeClient = tracker?.hasActiveClient ?? false;

  _InjectionMethod methodUsed = _InjectionMethod.rawKeyEvent;

  for (final token in tokens) {
    if (token.isSpecialKey) {
      // Special keys always use raw key events (or IME for some like backspace)
      await _handleSpecialKey(token.value, tracker: tracker);
    } else if (hasImeClient && tracker != null) {
      // Primary: Use low-level IME channel injection
      await tracker.injectText(token.value);
      methodUsed = _InjectionMethod.imeChannel;
    } else {
      // Try to find TextInputClient in widget tree
      final textInputClient = _findTextInputClient();
      if (textInputClient != null) {
        await _insertViaTextInputClient(textInputClient, token.value);
        methodUsed = _InjectionMethod.textInputClient;
      } else {
        // Fallback: raw key events for Focus-based widgets
        for (final char in token.value.split('')) {
          await _simulateCharacterKeyPress(char);
          await Future.delayed(const Duration(milliseconds: 30));
        }
        methodUsed = _InjectionMethod.rawKeyEvent;
      }
    }
  }

    return methodUsed;
}

// ============================================================================
// Text Input Tracker - Intercepts IME channel to track client state
// ============================================================================

/// Tracks TextInput state by intercepting outgoing messages.
///
/// Uses `TextInput.setChannel()` to wrap the text input channel and monitor
/// when TextInput clients are created/destroyed and their current state.
class _TextInputTracker {
  _TextInputTracker._();

  int? _currentClientId;
  TextEditingValue? _currentValue;
  _InterceptingBinaryMessenger? _messenger;

  bool get hasActiveClient => _currentClientId != null;
  int? get currentClientId => _currentClientId;
  TextEditingValue? get currentValue => _currentValue;

  /// Install the tracker by wrapping the TextInput channel
  static _TextInputTracker install() {
    final tracker = _TextInputTracker._();
    tracker._install();
    return tracker;
  }

  void _install() {
    // Wrap the default binary messenger to intercept OUTGOING messages
    final defaultMessenger = ServicesBinding.instance.defaultBinaryMessenger;
    _messenger = _InterceptingBinaryMessenger(
      defaultMessenger,
      onTextInputMessage: _handleOutgoingMessage,
    );

    // Replace the TextInput channel with our intercepting version
    final interceptingChannel = MethodChannel(
      'flutter/textinput',
      const JSONMethodCodec(),
      _messenger,
    );
    TextInput.setChannel(interceptingChannel);

      }

  void _handleOutgoingMessage(MethodCall call) {
    switch (call.method) {
      case 'TextInput.setClient':
        final args = call.arguments as List<dynamic>;
        _currentClientId = args[0] as int;
        
      case 'TextInput.setEditingState':
        final args = call.arguments as Map<dynamic, dynamic>;
        _currentValue = _decodeEditingValue(args);

      case 'TextInput.clearClient':
                _currentClientId = null;
        _currentValue = null;
    }
  }

  /// Inject text via the IME channel (simulates platform â†’ framework message)
  Future<bool> injectText(String text) async {
    if (_currentClientId == null) return false;

    final current = _currentValue ?? TextEditingValue.empty;
    final selection = current.selection;

    // Calculate new text
    String newText;
    int newCursorPos;

    if (selection.isValid && selection.start >= 0) {
      newText = current.text.replaceRange(selection.start, selection.end, text);
      newCursorPos = selection.start + text.length;
    } else {
      newText = current.text + text;
      newCursorPos = newText.length;
    }

    final newValue = TextEditingValue(
      text: newText,
      selection: TextSelection.collapsed(offset: newCursorPos),
    );

    return _sendEditingState(newValue);
  }

  /// Delete characters (backspace)
  Future<bool> deleteBackward({int count = 1}) async {
    if (_currentClientId == null || _currentValue == null) return false;

    final current = _currentValue!;
    final selection = current.selection;

    if (!selection.isValid || selection.start < 0) return false;

    String newText;
    int newCursorPos;

    if (selection.isCollapsed) {
      final deleteStart = (selection.start - count).clamp(0, selection.start);
      newText = current.text.replaceRange(deleteStart, selection.start, '');
      newCursorPos = deleteStart;
    } else {
      newText = current.text.replaceRange(selection.start, selection.end, '');
      newCursorPos = selection.start;
    }

    return _sendEditingState(TextEditingValue(
      text: newText,
      selection: TextSelection.collapsed(offset: newCursorPos),
    ));
  }

  /// Send editing state to the framework (simulates platform message)
  Future<bool> _sendEditingState(TextEditingValue value) async {
    if (_currentClientId == null) return false;

    _currentValue = value;

    final encoded = const JSONMethodCodec().encodeMethodCall(
      MethodCall('TextInputClient.updateEditingState', <dynamic>[
        _currentClientId,
        _encodeEditingValue(value),
      ]),
    );

    try {
      ServicesBinding.instance.channelBuffers.push(
        'flutter/textinput',
        encoded,
        (ByteData? reply) {},
      );
      return true;
    } catch (e) {
            return false;
    }
  }

  Map<String, dynamic> _encodeEditingValue(TextEditingValue value) {
    return <String, dynamic>{
      'text': value.text,
      'selectionBase': value.selection.baseOffset,
      'selectionExtent': value.selection.extentOffset,
      'selectionAffinity': value.selection.affinity.toString().split('.').last,
      'selectionIsDirectional': value.selection.isDirectional,
      'composingBase': value.composing.start,
      'composingExtent': value.composing.end,
    };
  }

  TextEditingValue _decodeEditingValue(Map<dynamic, dynamic> encoded) {
    return TextEditingValue(
      text: encoded['text'] as String? ?? '',
      selection: TextSelection(
        baseOffset: encoded['selectionBase'] as int? ?? -1,
        extentOffset: encoded['selectionExtent'] as int? ?? -1,
        isDirectional: encoded['selectionIsDirectional'] as bool? ?? false,
      ),
      composing: TextRange(
        start: encoded['composingBase'] as int? ?? -1,
        end: encoded['composingExtent'] as int? ?? -1,
      ),
    );
  }
}

/// BinaryMessenger wrapper that intercepts outgoing messages to flutter/textinput
class _InterceptingBinaryMessenger implements BinaryMessenger {
  final BinaryMessenger _delegate;
  final void Function(MethodCall call) onTextInputMessage;

  static const _textInputChannel = 'flutter/textinput';
  static const _codec = JSONMethodCodec();

  _InterceptingBinaryMessenger(this._delegate,
      {required this.onTextInputMessage});

  @override
  Future<ByteData?>? send(String channel, ByteData? message) {
    if (channel == _textInputChannel && message != null) {
      try {
        final call = _codec.decodeMethodCall(message);
        onTextInputMessage(call);
      } catch (e) {
        // Ignore decode errors
      }
    }
    return _delegate.send(channel, message);
  }

  @override
  void setMessageHandler(String channel, MessageHandler? handler) {
    _delegate.setMessageHandler(channel, handler);
  }

  @override
  Future<void> handlePlatformMessage(
    String channel,
    ByteData? data,
    ui.PlatformMessageResponseCallback? callback,
  ) {
    return _delegate.handlePlatformMessage(channel, data, callback);
  }
}

// ============================================================================
// Widget Tree TextInputClient Detection (Fallback)
// ============================================================================

/// Find a TextInputClient in the widget tree from the focused element.
/// Searches both descendants AND ancestors since EditableTextState is a child.
TextInputClient? _findTextInputClient() {
  final focusNode = FocusManager.instance.primaryFocus;
  if (focusNode == null) return null;

  final context = focusNode.context;
  if (context == null) return null;

  // Check if focused element itself is TextInputClient
  if (context is StatefulElement && context.state is TextInputClient) {
    return context.state as TextInputClient;
  }

  // Search DESCENDANTS (EditableTextState is a child of Focus)
  TextInputClient? client;
  void visitChildren(Element element) {
    if (client != null) return;
    if (element is StatefulElement && element.state is TextInputClient) {
      client = element.state as TextInputClient;
      return;
    }
    element.visitChildren(visitChildren);
  }

  (context as Element).visitChildren(visitChildren);
  if (client != null) return client;

  // Search ANCESTORS as fallback
  context.visitAncestorElements((element) {
    if (element is StatefulElement && element.state is TextInputClient) {
      client = element.state as TextInputClient;
      return false;
    }
    return true;
  });

  return client;
}

/// Insert text via TextInputClient (direct widget API)
Future<void> _insertViaTextInputClient(
    TextInputClient client, String text) async {
  final current = client.currentTextEditingValue ?? TextEditingValue.empty;
  final selection = current.selection;

  final newText = selection.isValid
      ? current.text.replaceRange(selection.start, selection.end, text)
      : current.text + text;

  final newCursorPosition =
      selection.isValid ? selection.start + text.length : newText.length;

  final newValue = TextEditingValue(
    text: newText,
    selection: TextSelection.collapsed(offset: newCursorPosition),
  );

  client.updateEditingValue(newValue);
  await Future.delayed(const Duration(milliseconds: 30));
}

// ============================================================================
// Token Parsing
// ============================================================================

List<_TypeToken> _parseText(String text) {
  final tokens = <_TypeToken>[];
  var lastEnd = 0;

  for (final match in _specialKeyPattern.allMatches(text)) {
    if (match.start > lastEnd) {
      tokens.add(_TypeToken(text.substring(lastEnd, match.start),
          isSpecialKey: false));
    }
    tokens.add(_TypeToken(match.group(1)!, isSpecialKey: true));
    lastEnd = match.end;
  }

  if (lastEnd < text.length) {
    tokens.add(_TypeToken(text.substring(lastEnd), isSpecialKey: false));
  }

  return tokens;
}

class _TypeToken {
  final String value;
  final bool isSpecialKey;
  _TypeToken(this.value, {required this.isSpecialKey});
}

// ============================================================================
// Special Key Handling
// ============================================================================

/// Handle special key actions
Future<void> _handleSpecialKey(String keySpec,
    {_TextInputTracker? tracker}) async {
  final parts = keySpec.toLowerCase().split('+');

  var ctrl = false;
  var alt = false;
  var shift = false;
  var meta = false;
  String? mainKey;

  for (final part in parts) {
    switch (part) {
      case 'ctrl' || 'control':
        ctrl = true;
      case 'alt' || 'option':
        alt = true;
      case 'shift':
        shift = true;
      case 'meta' || 'cmd' || 'command' || 'win' || 'super':
        meta = true;
      default:
        mainKey = part;
    }
  }

  if (mainKey == null) return;

  // For some keys, use IME if available and no modifiers
  if (tracker != null && tracker.hasActiveClient && !ctrl && !alt && !meta) {
    switch (mainKey) {
      case 'backspace':
        await tracker.deleteBackward();
        return;
      case 'enter' || 'return':
        await tracker.injectText('\n');
        return;
      case 'tab':
        await tracker.injectText('\t');
        return;
    }
  }

  // Fall back to raw key events
  final keyInfo = _getSpecialKeyInfo(mainKey);
  if (keyInfo == null) return;

  // Press modifiers
  if (ctrl)
    await _sendKeyDown(
        physicalKey: PhysicalKeyboardKey.controlLeft,
        logicalKey: LogicalKeyboardKey.controlLeft);
  if (alt)
    await _sendKeyDown(
        physicalKey: PhysicalKeyboardKey.altLeft,
        logicalKey: LogicalKeyboardKey.altLeft);
  if (shift)
    await _sendKeyDown(
        physicalKey: PhysicalKeyboardKey.shiftLeft,
        logicalKey: LogicalKeyboardKey.shiftLeft);
  if (meta)
    await _sendKeyDown(
        physicalKey: PhysicalKeyboardKey.metaLeft,
        logicalKey: LogicalKeyboardKey.metaLeft);

  if (ctrl || alt || shift || meta) {
    await Future.delayed(const Duration(milliseconds: 5));
  }

  // Press main key
  await _sendKeyDown(
    physicalKey: keyInfo.physicalKey,
    logicalKey: keyInfo.logicalKey,
    character: keyInfo.character,
  );
  await Future.delayed(const Duration(milliseconds: 10));
  await _sendKeyUp(
      physicalKey: keyInfo.physicalKey, logicalKey: keyInfo.logicalKey);

  // Release modifiers
  if (meta) {
    await Future.delayed(const Duration(milliseconds: 5));
    await _sendKeyUp(
        physicalKey: PhysicalKeyboardKey.metaLeft,
        logicalKey: LogicalKeyboardKey.metaLeft);
  }
  if (shift) {
    await Future.delayed(const Duration(milliseconds: 5));
    await _sendKeyUp(
        physicalKey: PhysicalKeyboardKey.shiftLeft,
        logicalKey: LogicalKeyboardKey.shiftLeft);
  }
  if (alt) {
    await Future.delayed(const Duration(milliseconds: 5));
    await _sendKeyUp(
        physicalKey: PhysicalKeyboardKey.altLeft,
        logicalKey: LogicalKeyboardKey.altLeft);
  }
  if (ctrl) {
    await Future.delayed(const Duration(milliseconds: 5));
    await _sendKeyUp(
        physicalKey: PhysicalKeyboardKey.controlLeft,
        logicalKey: LogicalKeyboardKey.controlLeft);
  }

  await Future.delayed(const Duration(milliseconds: 30));
}

// ============================================================================
// Raw Key Event Simulation
// ============================================================================

Future<void> _simulateCharacterKeyPress(String char) async {
  final keyInfo = _getKeyInfoForCharacter(char);
  if (keyInfo == null) return;

  if (keyInfo.needsShift) {
    await _sendKeyDown(
        physicalKey: PhysicalKeyboardKey.shiftLeft,
        logicalKey: LogicalKeyboardKey.shiftLeft);
    await Future.delayed(const Duration(milliseconds: 5));
  }

  await _sendKeyDown(
      physicalKey: keyInfo.physicalKey,
      logicalKey: keyInfo.logicalKey,
      character: char);
  await Future.delayed(const Duration(milliseconds: 10));
  await _sendKeyUp(
      physicalKey: keyInfo.physicalKey, logicalKey: keyInfo.logicalKey);

  if (keyInfo.needsShift) {
    await Future.delayed(const Duration(milliseconds: 5));
    await _sendKeyUp(
        physicalKey: PhysicalKeyboardKey.shiftLeft,
        logicalKey: LogicalKeyboardKey.shiftLeft);
  }
}

Future<bool> _sendKeyDown({
  required PhysicalKeyboardKey physicalKey,
  required LogicalKeyboardKey logicalKey,
  String? character,
}) async {
  final primaryFocus = FocusManager.instance.primaryFocus;
  if (primaryFocus == null) return false;

  final keyEvent = KeyDownEvent(
    physicalKey: physicalKey,
    logicalKey: logicalKey,
    character: character,
    timeStamp: Duration.zero,
  );

  final onKeyEvent = primaryFocus.onKeyEvent;
  if (onKeyEvent != null) {
    final result = onKeyEvent(primaryFocus, keyEvent);
    // For xterm-style widgets, character insertion happens in onKeyEvent
    if (keyEvent.character != null && keyEvent.character!.isNotEmpty) {
      return true;
    }
    return result == KeyEventResult.handled;
  }

  // Fallback: HardwareKeyboard API
  return ServicesBinding.instance.keyEventManager.handleKeyData(
    ui.KeyData(
      type: ui.KeyEventType.down,
      physical: physicalKey.usbHidUsage,
      logical: logicalKey.keyId,
      timeStamp: Duration.zero,
      character: character,
      synthesized: true,
    ),
  );
}

Future<bool> _sendKeyUp({
  required PhysicalKeyboardKey physicalKey,
  required LogicalKeyboardKey logicalKey,
}) async {
  final primaryFocus = FocusManager.instance.primaryFocus;
  if (primaryFocus == null) return false;

  final keyEvent = KeyUpEvent(
    physicalKey: physicalKey,
    logicalKey: logicalKey,
    timeStamp: Duration.zero,
  );

  final onKeyEvent = primaryFocus.onKeyEvent;
  if (onKeyEvent != null) {
    final result = onKeyEvent(primaryFocus, keyEvent);
    return result == KeyEventResult.handled;
  }

  return ServicesBinding.instance.keyEventManager.handleKeyData(
    ui.KeyData(
      type: ui.KeyEventType.up,
      physical: physicalKey.usbHidUsage,
      logical: logicalKey.keyId,
      timeStamp: Duration.zero,
      character: null,
      synthesized: true,
    ),
  );
}

// ============================================================================
// Key Info Structures and Mappings
// ============================================================================

class _SpecialKeyInfo {
  final PhysicalKeyboardKey physicalKey;
  final LogicalKeyboardKey logicalKey;
  final String? character;
  const _SpecialKeyInfo(this.physicalKey, this.logicalKey, [this.character]);
}

_SpecialKeyInfo? _getSpecialKeyInfo(String key) {
  return switch (key) {
    'enter' || 'return' => const _SpecialKeyInfo(
        PhysicalKeyboardKey.enter, LogicalKeyboardKey.enter, '\n'),
    'tab' => const _SpecialKeyInfo(
        PhysicalKeyboardKey.tab, LogicalKeyboardKey.tab, '\t'),
    'backspace' => const _SpecialKeyInfo(
        PhysicalKeyboardKey.backspace, LogicalKeyboardKey.backspace),
    'delete' || 'del' => const _SpecialKeyInfo(
        PhysicalKeyboardKey.delete, LogicalKeyboardKey.delete),
    'escape' || 'esc' => const _SpecialKeyInfo(
        PhysicalKeyboardKey.escape, LogicalKeyboardKey.escape),
    'space' => const _SpecialKeyInfo(
        PhysicalKeyboardKey.space, LogicalKeyboardKey.space, ' '),
    'left' || 'arrowleft' => const _SpecialKeyInfo(
        PhysicalKeyboardKey.arrowLeft, LogicalKeyboardKey.arrowLeft),
    'right' || 'arrowright' => const _SpecialKeyInfo(
        PhysicalKeyboardKey.arrowRight, LogicalKeyboardKey.arrowRight),
    'up' || 'arrowup' => const _SpecialKeyInfo(
        PhysicalKeyboardKey.arrowUp, LogicalKeyboardKey.arrowUp),
    'down' || 'arrowdown' => const _SpecialKeyInfo(
        PhysicalKeyboardKey.arrowDown, LogicalKeyboardKey.arrowDown),
    'home' =>
      const _SpecialKeyInfo(PhysicalKeyboardKey.home, LogicalKeyboardKey.home),
    'end' =>
      const _SpecialKeyInfo(PhysicalKeyboardKey.end, LogicalKeyboardKey.end),
    'pageup' || 'pgup' => const _SpecialKeyInfo(
        PhysicalKeyboardKey.pageUp, LogicalKeyboardKey.pageUp),
    'pagedown' || 'pgdn' => const _SpecialKeyInfo(
        PhysicalKeyboardKey.pageDown, LogicalKeyboardKey.pageDown),
    'insert' || 'ins' => const _SpecialKeyInfo(
        PhysicalKeyboardKey.insert, LogicalKeyboardKey.insert),
    'f1' =>
      const _SpecialKeyInfo(PhysicalKeyboardKey.f1, LogicalKeyboardKey.f1),
    'f2' =>
      const _SpecialKeyInfo(PhysicalKeyboardKey.f2, LogicalKeyboardKey.f2),
    'f3' =>
      const _SpecialKeyInfo(PhysicalKeyboardKey.f3, LogicalKeyboardKey.f3),
    'f4' =>
      const _SpecialKeyInfo(PhysicalKeyboardKey.f4, LogicalKeyboardKey.f4),
    'f5' =>
      const _SpecialKeyInfo(PhysicalKeyboardKey.f5, LogicalKeyboardKey.f5),
    'f6' =>
      const _SpecialKeyInfo(PhysicalKeyboardKey.f6, LogicalKeyboardKey.f6),
    'f7' =>
      const _SpecialKeyInfo(PhysicalKeyboardKey.f7, LogicalKeyboardKey.f7),
    'f8' =>
      const _SpecialKeyInfo(PhysicalKeyboardKey.f8, LogicalKeyboardKey.f8),
    'f9' =>
      const _SpecialKeyInfo(PhysicalKeyboardKey.f9, LogicalKeyboardKey.f9),
    'f10' =>
      const _SpecialKeyInfo(PhysicalKeyboardKey.f10, LogicalKeyboardKey.f10),
    'f11' =>
      const _SpecialKeyInfo(PhysicalKeyboardKey.f11, LogicalKeyboardKey.f11),
    'f12' =>
      const _SpecialKeyInfo(PhysicalKeyboardKey.f12, LogicalKeyboardKey.f12),
    _ when key.length == 1 => _getSingleCharSpecialKey(key),
    _ => null,
  };
}

_SpecialKeyInfo? _getSingleCharSpecialKey(String char) {
  final code = char.codeUnitAt(0);
  if (code >= 97 && code <= 122) {
    // a-z
    final keyInfo = _getLowercaseLetterKey(char);
    if (keyInfo != null)
      return _SpecialKeyInfo(keyInfo.physicalKey, keyInfo.logicalKey, char);
  }
  if (code >= 48 && code <= 57) {
    // 0-9
    final keyInfo = _getDigitKey(char);
    if (keyInfo != null)
      return _SpecialKeyInfo(keyInfo.physicalKey, keyInfo.logicalKey, char);
  }
  return null;
}

class _KeyInfo {
  final PhysicalKeyboardKey physicalKey;
  final LogicalKeyboardKey logicalKey;
  final bool needsShift;
  const _KeyInfo(
      {required this.physicalKey,
      required this.logicalKey,
      this.needsShift = false});
}

_KeyInfo? _getKeyInfoForCharacter(String char) {
  final code = char.codeUnitAt(0);

  if (code >= 97 && code <= 122) return _getLowercaseLetterKey(char);
  if (code >= 65 && code <= 90) return _getUppercaseLetterKey(char);
  if (code >= 48 && code <= 57) return _getDigitKey(char);
  if (char == ' ')
    return const _KeyInfo(
        physicalKey: PhysicalKeyboardKey.space,
        logicalKey: LogicalKeyboardKey.space);

  return _getSymbolKey(char);
}

_KeyInfo? _getLowercaseLetterKey(String char) {
  final offset = char.codeUnitAt(0) - 97;
  final physical = _letterPhysicalKeys[offset];
  final logical = _letterLogicalKeys[offset];
  if (physical == null || logical == null) return null;
  return _KeyInfo(physicalKey: physical, logicalKey: logical);
}

_KeyInfo? _getUppercaseLetterKey(String char) {
  final offset = char.toLowerCase().codeUnitAt(0) - 97;
  final physical = _letterPhysicalKeys[offset];
  final logical = _letterLogicalKeys[offset];
  if (physical == null || logical == null) return null;
  return _KeyInfo(physicalKey: physical, logicalKey: logical, needsShift: true);
}

_KeyInfo? _getDigitKey(String char) {
  final offset = char.codeUnitAt(0) - 48;
  final physical = _digitPhysicalKeys[offset];
  final logical = _digitLogicalKeys[offset];
  if (physical == null || logical == null) return null;
  return _KeyInfo(physicalKey: physical, logicalKey: logical);
}

_KeyInfo? _getSymbolKey(String char) {
  return switch (char) {
    '-' => const _KeyInfo(
        physicalKey: PhysicalKeyboardKey.minus,
        logicalKey: LogicalKeyboardKey.minus),
    '=' => const _KeyInfo(
        physicalKey: PhysicalKeyboardKey.equal,
        logicalKey: LogicalKeyboardKey.equal),
    '[' => const _KeyInfo(
        physicalKey: PhysicalKeyboardKey.bracketLeft,
        logicalKey: LogicalKeyboardKey.bracketLeft),
    ']' => const _KeyInfo(
        physicalKey: PhysicalKeyboardKey.bracketRight,
        logicalKey: LogicalKeyboardKey.bracketRight),
    '\\' => const _KeyInfo(
        physicalKey: PhysicalKeyboardKey.backslash,
        logicalKey: LogicalKeyboardKey.backslash),
    ';' => const _KeyInfo(
        physicalKey: PhysicalKeyboardKey.semicolon,
        logicalKey: LogicalKeyboardKey.semicolon),
    "'" => const _KeyInfo(
        physicalKey: PhysicalKeyboardKey.quote,
        logicalKey: LogicalKeyboardKey.quoteSingle),
    '`' => const _KeyInfo(
        physicalKey: PhysicalKeyboardKey.backquote,
        logicalKey: LogicalKeyboardKey.backquote),
    ',' => const _KeyInfo(
        physicalKey: PhysicalKeyboardKey.comma,
        logicalKey: LogicalKeyboardKey.comma),
    '.' => const _KeyInfo(
        physicalKey: PhysicalKeyboardKey.period,
        logicalKey: LogicalKeyboardKey.period),
    '/' => const _KeyInfo(
        physicalKey: PhysicalKeyboardKey.slash,
        logicalKey: LogicalKeyboardKey.slash),
    '!' => const _KeyInfo(
        physicalKey: PhysicalKeyboardKey.digit1,
        logicalKey: LogicalKeyboardKey.exclamation,
        needsShift: true),
    '@' => const _KeyInfo(
        physicalKey: PhysicalKeyboardKey.digit2,
        logicalKey: LogicalKeyboardKey.at,
        needsShift: true),
    '#' => const _KeyInfo(
        physicalKey: PhysicalKeyboardKey.digit3,
        logicalKey: LogicalKeyboardKey.numberSign,
        needsShift: true),
    '\$' => const _KeyInfo(
        physicalKey: PhysicalKeyboardKey.digit4,
        logicalKey: LogicalKeyboardKey.dollar,
        needsShift: true),
    '%' => const _KeyInfo(
        physicalKey: PhysicalKeyboardKey.digit5,
        logicalKey: LogicalKeyboardKey.percent,
        needsShift: true),
    '^' => const _KeyInfo(
        physicalKey: PhysicalKeyboardKey.digit6,
        logicalKey: LogicalKeyboardKey.caret,
        needsShift: true),
    '&' => const _KeyInfo(
        physicalKey: PhysicalKeyboardKey.digit7,
        logicalKey: LogicalKeyboardKey.ampersand,
        needsShift: true),
    '*' => const _KeyInfo(
        physicalKey: PhysicalKeyboardKey.digit8,
        logicalKey: LogicalKeyboardKey.asterisk,
        needsShift: true),
    '(' => const _KeyInfo(
        physicalKey: PhysicalKeyboardKey.digit9,
        logicalKey: LogicalKeyboardKey.parenthesisLeft,
        needsShift: true),
    ')' => const _KeyInfo(
        physicalKey: PhysicalKeyboardKey.digit0,
        logicalKey: LogicalKeyboardKey.parenthesisRight,
        needsShift: true),
    '_' => const _KeyInfo(
        physicalKey: PhysicalKeyboardKey.minus,
        logicalKey: LogicalKeyboardKey.underscore,
        needsShift: true),
    '+' => const _KeyInfo(
        physicalKey: PhysicalKeyboardKey.equal,
        logicalKey: LogicalKeyboardKey.add,
        needsShift: true),
    '{' => const _KeyInfo(
        physicalKey: PhysicalKeyboardKey.bracketLeft,
        logicalKey: LogicalKeyboardKey.braceLeft,
        needsShift: true),
    '}' => const _KeyInfo(
        physicalKey: PhysicalKeyboardKey.bracketRight,
        logicalKey: LogicalKeyboardKey.braceRight,
        needsShift: true),
    '|' => const _KeyInfo(
        physicalKey: PhysicalKeyboardKey.backslash,
        logicalKey: LogicalKeyboardKey.bar,
        needsShift: true),
    ':' => const _KeyInfo(
        physicalKey: PhysicalKeyboardKey.semicolon,
        logicalKey: LogicalKeyboardKey.colon,
        needsShift: true),
    '"' => const _KeyInfo(
        physicalKey: PhysicalKeyboardKey.quote,
        logicalKey: LogicalKeyboardKey.quote,
        needsShift: true),
    '~' => const _KeyInfo(
        physicalKey: PhysicalKeyboardKey.backquote,
        logicalKey: LogicalKeyboardKey.tilde,
        needsShift: true),
    '<' => const _KeyInfo(
        physicalKey: PhysicalKeyboardKey.comma,
        logicalKey: LogicalKeyboardKey.less,
        needsShift: true),
    '>' => const _KeyInfo(
        physicalKey: PhysicalKeyboardKey.period,
        logicalKey: LogicalKeyboardKey.greater,
        needsShift: true),
    '?' => const _KeyInfo(
        physicalKey: PhysicalKeyboardKey.slash,
        logicalKey: LogicalKeyboardKey.question,
        needsShift: true),
    _ => null,
  };
}

const _letterPhysicalKeys = <int, PhysicalKeyboardKey>{
  0: PhysicalKeyboardKey.keyA,
  1: PhysicalKeyboardKey.keyB,
  2: PhysicalKeyboardKey.keyC,
  3: PhysicalKeyboardKey.keyD,
  4: PhysicalKeyboardKey.keyE,
  5: PhysicalKeyboardKey.keyF,
  6: PhysicalKeyboardKey.keyG,
  7: PhysicalKeyboardKey.keyH,
  8: PhysicalKeyboardKey.keyI,
  9: PhysicalKeyboardKey.keyJ,
  10: PhysicalKeyboardKey.keyK,
  11: PhysicalKeyboardKey.keyL,
  12: PhysicalKeyboardKey.keyM,
  13: PhysicalKeyboardKey.keyN,
  14: PhysicalKeyboardKey.keyO,
  15: PhysicalKeyboardKey.keyP,
  16: PhysicalKeyboardKey.keyQ,
  17: PhysicalKeyboardKey.keyR,
  18: PhysicalKeyboardKey.keyS,
  19: PhysicalKeyboardKey.keyT,
  20: PhysicalKeyboardKey.keyU,
  21: PhysicalKeyboardKey.keyV,
  22: PhysicalKeyboardKey.keyW,
  23: PhysicalKeyboardKey.keyX,
  24: PhysicalKeyboardKey.keyY,
  25: PhysicalKeyboardKey.keyZ,
};

const _letterLogicalKeys = <int, LogicalKeyboardKey>{
  0: LogicalKeyboardKey.keyA,
  1: LogicalKeyboardKey.keyB,
  2: LogicalKeyboardKey.keyC,
  3: LogicalKeyboardKey.keyD,
  4: LogicalKeyboardKey.keyE,
  5: LogicalKeyboardKey.keyF,
  6: LogicalKeyboardKey.keyG,
  7: LogicalKeyboardKey.keyH,
  8: LogicalKeyboardKey.keyI,
  9: LogicalKeyboardKey.keyJ,
  10: LogicalKeyboardKey.keyK,
  11: LogicalKeyboardKey.keyL,
  12: LogicalKeyboardKey.keyM,
  13: LogicalKeyboardKey.keyN,
  14: LogicalKeyboardKey.keyO,
  15: LogicalKeyboardKey.keyP,
  16: LogicalKeyboardKey.keyQ,
  17: LogicalKeyboardKey.keyR,
  18: LogicalKeyboardKey.keyS,
  19: LogicalKeyboardKey.keyT,
  20: LogicalKeyboardKey.keyU,
  21: LogicalKeyboardKey.keyV,
  22: LogicalKeyboardKey.keyW,
  23: LogicalKeyboardKey.keyX,
  24: LogicalKeyboardKey.keyY,
  25: LogicalKeyboardKey.keyZ,
};

const _digitPhysicalKeys = <int, PhysicalKeyboardKey>{
  0: PhysicalKeyboardKey.digit0,
  1: PhysicalKeyboardKey.digit1,
  2: PhysicalKeyboardKey.digit2,
  3: PhysicalKeyboardKey.digit3,
  4: PhysicalKeyboardKey.digit4,
  5: PhysicalKeyboardKey.digit5,
  6: PhysicalKeyboardKey.digit6,
  7: PhysicalKeyboardKey.digit7,
  8: PhysicalKeyboardKey.digit8,
  9: PhysicalKeyboardKey.digit9,
};

const _digitLogicalKeys = <int, LogicalKeyboardKey>{
  0: LogicalKeyboardKey.digit0,
  1: LogicalKeyboardKey.digit1,
  2: LogicalKeyboardKey.digit2,
  3: LogicalKeyboardKey.digit3,
  4: LogicalKeyboardKey.digit4,
  5: LogicalKeyboardKey.digit5,
  6: LogicalKeyboardKey.digit6,
  7: LogicalKeyboardKey.digit7,
  8: LogicalKeyboardKey.digit8,
  9: LogicalKeyboardKey.digit9,
};

// ============================================================================
// scroll_extension.dart
// ============================================================================

/// Counter for unique pointer IDs in scroll gestures.
/// Starts high to avoid conflicts with tap pointer IDs.
int _nextScrollPointer = 10000;

int _getNextScrollPointer() {
  final result = _nextScrollPointer;
  _nextScrollPointer += 1;
  return result;
}

/// Registers the scroll service extension
void _registerScrollExtension() {
  
  developer.registerExtension(
    'ext.runtime_ai_dev_tools.scroll',
    (String method, Map<String, String> parameters) async {
                  
      try {
        final startXStr = parameters['startX'];
        final startYStr = parameters['startY'];
        final dxStr = parameters['dx'];
        final dyStr = parameters['dy'];
        final durationMsStr = parameters['durationMs'];

        if (startXStr == null || startYStr == null) {
          return developer.ServiceExtensionResponse.error(
            developer.ServiceExtensionResponse.invalidParams,
            'Missing required parameters: startX and startY',
          );
        }

        if (dxStr == null || dyStr == null) {
          return developer.ServiceExtensionResponse.error(
            developer.ServiceExtensionResponse.invalidParams,
            'Missing required parameters: dx and dy',
          );
        }

        final startX = double.tryParse(startXStr);
        final startY = double.tryParse(startYStr);
        final dx = double.tryParse(dxStr);
        final dy = double.tryParse(dyStr);

        if (startX == null || startY == null || dx == null || dy == null) {
          return developer.ServiceExtensionResponse.error(
            developer.ServiceExtensionResponse.invalidParams,
            'Invalid coordinate values',
          );
        }

        final durationMs =
            durationMsStr != null ? int.tryParse(durationMsStr) : 300;
        final duration = Duration(milliseconds: durationMs ?? 300);

        await _simulateScroll(
          startX: startX,
          startY: startY,
          dx: dx,
          dy: dy,
          duration: duration,
        );

        return developer.ServiceExtensionResponse.result(
          json.encode({
            'status': 'success',
            'startX': startX,
            'startY': startY,
            'dx': dx,
            'dy': dy,
            'durationMs': duration.inMilliseconds,
          }),
        );
      } catch (e, stackTrace) {
        return developer.ServiceExtensionResponse.error(
          developer.ServiceExtensionResponse.extensionError,
          'Failed to simulate scroll: $e\n$stackTrace',
        );
      }
    },
  );
}

/// Simulates a scroll/drag gesture from start position with given delta
Future<void> _simulateScroll({
  required double startX,
  required double startY,
  required double dx,
  required double dy,
  required Duration duration,
}) async {
        
  final binding = WidgetsBinding.instance;
  final endX = startX + dx;
  final endY = startY + dy;
  final pointer = _getNextScrollPointer();
  
  // Show scroll visualization
  final rootContext = binding.rootElement;
  if (rootContext != null) {
        try {
      _TapVisualizationService().showScrollPath(
        rootContext,
        Offset(startX, startY),
        Offset(endX, endY),
        duration,
      );
    } catch (e) {
            // Continue even if visualization fails
    }
  }

  // Calculate steps based on duration (target ~16ms per step for smooth animation)
  final steps = (duration.inMilliseconds / 16).round().clamp(5, 60);
  final stepDelay = Duration(milliseconds: duration.inMilliseconds ~/ steps);

  
  // Register the pointer device first
    binding.handlePointerEvent(PointerAddedEvent(
    position: Offset(startX, startY),
    pointer: pointer,
  ));
  
  // Pointer down at start with unique pointer ID
    binding.handlePointerEvent(PointerDownEvent(
    position: Offset(startX, startY),
    pointer: pointer,
  ));

  // Move through interpolated positions
  for (var i = 1; i <= steps; i++) {
    await Future.delayed(stepDelay);

    final progress = i / steps;
    final currentX = startX + dx * progress;
    final currentY = startY + dy * progress;

    binding.handlePointerEvent(PointerMoveEvent(
      position: Offset(currentX, currentY),
      delta: Offset(dx / steps, dy / steps),
      pointer: pointer,
    ));
  }

  // Pointer up at end with same pointer ID
    binding.handlePointerEvent(PointerUpEvent(
    position: Offset(endX, endY),
    pointer: pointer,
  ));

  // Unregister the pointer device
    binding.handlePointerEvent(PointerRemovedEvent(
    position: Offset(endX, endY),
    pointer: pointer,
  ));
  
  // Set persistent indicator at end position for screenshots
  if (rootContext != null) {
    try {
      _TapVisualizationService().setScrollEndIndicator(
        rootContext,
        Offset(startX, startY),
        Offset(endX, endY),
      );
    } catch (e) {
          }
  }

  }

// ============================================================================
// cursor_extension.dart
// ============================================================================

/// Registers cursor-related service extensions
///
/// - ext.runtime_ai_dev_tools.moveCursor - Move the cursor to a position
/// - ext.runtime_ai_dev_tools.getCursorPosition - Get current cursor position
void _registerCursorExtension() {
  
  // Move cursor extension
  developer.registerExtension(
    'ext.runtime_ai_dev_tools.moveCursor',
    (String method, Map<String, String> parameters) async {
            
      try {
        final xStr = parameters['x'];
        final yStr = parameters['y'];

        if (xStr == null || yStr == null) {
          return developer.ServiceExtensionResponse.error(
            developer.ServiceExtensionResponse.invalidParams,
            'Missing required parameters: x and y',
          );
        }

        final x = double.tryParse(xStr);
        final y = double.tryParse(yStr);

        if (x == null || y == null) {
          return developer.ServiceExtensionResponse.error(
            developer.ServiceExtensionResponse.invalidParams,
            'Invalid x or y coordinate',
          );
        }

        // Set the cursor position (without requiring BuildContext for overlay)
        _TapVisualizationService().setCursorPosition(x, y);

        return developer.ServiceExtensionResponse.result(
          json.encode({
            'status': 'success',
            'x': x,
            'y': y,
          }),
        );
      } catch (e, stackTrace) {
                        return developer.ServiceExtensionResponse.error(
          developer.ServiceExtensionResponse.extensionError,
          'Failed to move cursor: $e',
        );
      }
    },
  );

  // Get cursor position extension
  developer.registerExtension(
    'ext.runtime_ai_dev_tools.getCursorPosition',
    (String method, Map<String, String> parameters) async {
      
      try {
        final position = _TapVisualizationService().cursorPosition;

        if (position == null) {
          return developer.ServiceExtensionResponse.result(
            json.encode({
              'status': 'success',
              'hasPosition': false,
              'message': 'No cursor position set. Use moveCursor or tap first.',
            }),
          );
        }

        return developer.ServiceExtensionResponse.result(
          json.encode({
            'status': 'success',
            'hasPosition': true,
            'x': position.dx,
            'y': position.dy,
          }),
        );
      } catch (e, stackTrace) {
                        return developer.ServiceExtensionResponse.error(
          developer.ServiceExtensionResponse.extensionError,
          'Failed to get cursor position: $e',
        );
      }
    },
  );

  }

// ============================================================================
// widget_info_extension.dart
// ============================================================================

/// Registers the widget info service extension
///
/// This extension provides widget information at screen coordinates,
/// including source file location when available (debug mode with
/// --track-widget-creation enabled).
void _registerWidgetInfoExtension() {
  
  developer.registerExtension(
    'ext.runtime_ai_dev_tools.getWidgetInfo',
    (String method, Map<String, String> parameters) async {
                  
      try {
        final xStr = parameters['x'];
        final yStr = parameters['y'];

        if (xStr == null || yStr == null) {
          return developer.ServiceExtensionResponse.error(
            developer.ServiceExtensionResponse.invalidParams,
            'Missing required parameters: x and y',
          );
        }

        final x = double.tryParse(xStr);
        final y = double.tryParse(yStr);

        if (x == null || y == null) {
          return developer.ServiceExtensionResponse.error(
            developer.ServiceExtensionResponse.invalidParams,
            'Invalid x or y coordinate',
          );
        }

        final result = _getWidgetInfoAtPosition(x, y);

        return developer.ServiceExtensionResponse.result(json.encode(result));
      } catch (e, stackTrace) {
                        return developer.ServiceExtensionResponse.error(
          developer.ServiceExtensionResponse.extensionError,
          'Failed to get widget info: $e\n$stackTrace',
        );
      }
    },
  );
}

/// Get widget information at the specified screen coordinates
Map<String, dynamic> _getWidgetInfoAtPosition(double x, double y) {
  
  // Show inspection pulse animation
  _TapVisualizationService().showInspectionPulse(x, y);

  final binding = WidgetsBinding.instance;
  final renderView = binding.renderViews.firstOrNull;

  if (renderView == null) {
        return {
      'status': 'error',
      'error': 'No render view available',
    };
  }

  // Perform hit test at the position
  final position = Offset(x, y);
  final result = HitTestResult();
  renderView.hitTest(result, position: position);

  if (result.path.isEmpty) {
        return {
      'status': 'success',
      'widgets': <Map<String, dynamic>>[],
      'message': 'No widgets found at position ($x, $y)',
    };
  }

  
  // Collect widget information from hit test results
  final widgets = <Map<String, dynamic>>[];
  final seenElements = <Element>{};

  for (final entry in result.path) {
    final target = entry.target;
    if (target is! RenderObject) continue;

    // Find the Element that owns this RenderObject
    final element = _findElementForRenderObject(target);
    if (element == null) continue;

    // Skip if we've already processed this element
    if (seenElements.contains(element)) continue;
    seenElements.add(element);

    final widget = element.widget;
    final widgetInfo = _extractWidgetInfo(widget, element, target);
    if (widgetInfo != null) {
      widgets.add(widgetInfo);
    }
  }

  
  return {
    'status': 'success',
    'position': {'x': x, 'y': y},
    'widgets': widgets,
  };
}

/// Find the Element that owns a RenderObject
Element? _findElementForRenderObject(RenderObject renderObject) {
  Element? result;

  void visitor(Element element) {
    if (element.renderObject == renderObject) {
      result = element;
      return;
    }
    if (result == null) {
      element.visitChildren(visitor);
    }
  }

  final binding = WidgetsBinding.instance;
  binding.rootElement?.visitChildren(visitor);

  return result;
}

/// Extract widget information including source location
Map<String, dynamic>? _extractWidgetInfo(
  Widget widget,
  Element element,
  RenderObject renderObject,
) {
  final widgetType = widget.runtimeType.toString();

  // Get the render box bounds if available
  Map<String, dynamic>? bounds;
  if (renderObject is RenderBox && renderObject.hasSize) {
    try {
      final transform = renderObject.getTransformTo(null);
      final topLeft = MatrixUtils.transformPoint(transform, Offset.zero);
      final size = renderObject.size;

      bounds = {
        'x': topLeft.dx,
        'y': topLeft.dy,
        'width': size.width,
        'height': size.height,
      };
    } catch (e) {
      // Ignore bounds extraction errors
    }
  }

  // Try to get creation location (requires --track-widget-creation)
  final creationLocation = _getCreationLocation(element);

  // Build the widget info map
  final info = <String, dynamic>{
    'type': widgetType,
    'key': widget.key?.toString(),
  };

  if (bounds != null) {
    info['bounds'] = bounds;
  }

  if (creationLocation != null) {
    info['creationLocation'] = creationLocation;
  }

  // Add the debug creator chain (useful for finding source)
  try {
    info['creatorChain'] = element.debugGetCreatorChain(5);
  } catch (e) {
    // Ignore if not available
  }

  // Add some useful widget-specific properties
  _addWidgetSpecificInfo(widget, info);

  return info;
}

/// Try to get the creation location from an Element
///
/// This works when Flutter is run with --track-widget-creation (default in debug)
/// Uses WidgetInspectorService to access location data.
Map<String, dynamic>? _getCreationLocation(Element element) {
  try {
    // WidgetInspectorService provides access to creation locations
    // when --track-widget-creation is enabled (default in debug mode)
    if (!WidgetInspectorService.instance.isWidgetCreationTracked()) {
      return null;
    }

    // The inspector service can select and inspect widgets
    // We use it to get the creation location data
    final widget = element.widget;

    // Try to get location via the debug representation
    // The widget's toString in debug mode includes location info
    final debugString = widget.toStringShort();

    // Parse location from debug string if present (format: "WidgetName(file.dart:line)")
    final match = RegExp(r'\(([^:]+):(\d+)\)$').firstMatch(debugString);
    if (match != null) {
      return {
        'file': match.group(1),
        'line': int.tryParse(match.group(2) ?? ''),
      };
    }

    // Alternative: use toDiagnosticsNode to get structured info
    final diagnostics = widget.toDiagnosticsNode();
    for (final property in diagnostics.getProperties()) {
      final name = property.name?.toLowerCase() ?? '';
      if (name.contains('location') || name.contains('source')) {
        final value = property.value;
        if (value != null) {
          return {'debug': value.toString()};
        }
      }
    }
  } catch (e) {
    // Location tracking not available or failed
      }
  return null;
}

/// Add widget-specific properties that might be useful for understanding the widget
void _addWidgetSpecificInfo(Widget widget, Map<String, dynamic> info) {
  // Add text content for Text widgets
  if (widget is Text) {
    info['text'] = widget.data ?? widget.textSpan?.toPlainText();
  }

  // Add label/hint for input widgets
  if (widget is EditableText) {
    info['text'] = widget.controller.text;
  }

  // Add semantics label if available
  if (widget is Semantics) {
    info['semanticsLabel'] = widget.properties.label;
  }

  // Add icon data for Icon widgets
  if (widget is Icon) {
    info['icon'] = widget.icon?.codePoint;
  }

  // Add image info
  if (widget is Image) {
    final imageProvider = widget.image;
    info['imageType'] = imageProvider.runtimeType.toString();
  }
}

// ============================================================================
// debug_overlay_wrapper.dart
// ============================================================================

/// Wraps the app with a custom overlay for tap visualization
///
/// This widget creates its own overlay at the root of the widget tree,
/// giving us full control over tap visualization without relying on
/// Navigator's overlay or MaterialApp's overlay.
class _DebugOverlayWrapper extends StatefulWidget {
  final Widget child;

  const _DebugOverlayWrapper({
    super.key,
    required this.child,
  });

  @override
  State<_DebugOverlayWrapper> createState() => _DebugOverlayWrapperState();
}

class _DebugOverlayWrapperState extends State<_DebugOverlayWrapper> {
  final GlobalKey<OverlayState> _overlayKey = GlobalKey<OverlayState>();

  @override
  void initState() {
    super.initState();
    // Register our overlay with the tap visualization service
    _TapVisualizationService().setOverlayKey(_overlayKey);
  }

  @override
  Widget build(BuildContext context) {
    return Directionality(
      textDirection: TextDirection.ltr,
      child: Overlay(
        key: _overlayKey,
        initialEntries: [
          OverlayEntry(
            builder: (context) => widget.child,
          ),
        ],
      ),
    );
  }
}

// ============================================================================
// debug_binding.dart
// ============================================================================

/// Custom binding that automatically wraps the root widget with _DebugOverlayWrapper.
///
/// This binding intercepts the widget attachment process to inject the debug overlay
/// without requiring modification of the user's main.dart.
///
/// Usage in synthetic main:
/// ```dart
/// void main() {
///   _DebugWidgetsFlutterBinding.ensureInitialized();
///   RuntimeAiDevTools.registerExtensions();
///   user_app.main();
/// }
/// ```
class _DebugWidgetsFlutterBinding extends WidgetsFlutterBinding {
  /// Track if we've already wrapped to avoid double-wrapping
  bool _hasWrapped = false;

  /// Override wrapWithDefaultView to inject _DebugOverlayWrapper BEFORE the View wrapper.
  /// This is called by runApp before scheduleAttachRootWidget.
  @override
  Widget wrapWithDefaultView(Widget rootWidget) {
        if (_hasWrapped) {
            return super.wrapWithDefaultView(rootWidget);
    }
    _hasWrapped = true;
        // Wrap the user's widget with _DebugOverlayWrapper, then let the default View wrapper handle it
    return super.wrapWithDefaultView(_DebugOverlayWrapper(child: rootWidget));
  }

  /// Returns an instance of [_DebugWidgetsFlutterBinding], creating and
  /// initializing it if necessary.
  ///
  /// MUST be called before runApp() to ensure this binding is used.
  static WidgetsBinding ensureInitialized() {
    
    // Check if a binding already exists using the safe pattern
    // BindingBase.debugBindingType() is safe even when no binding exists
    final WidgetsBinding? existingBinding;
    try {
      existingBinding = WidgetsBinding.instance;
          } catch (e) {
      // No binding initialized yet - this is expected for first call
            _DebugWidgetsFlutterBinding();
            return WidgetsBinding.instance;
    }

    // A binding already exists
    if (existingBinding is _DebugWidgetsFlutterBinding) {
            return existingBinding;
    }

    // Different binding exists - warn but return it
            return existingBinding;
  }
}
''';
